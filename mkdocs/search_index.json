{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to the OpenMVG Erlang Tutorial\n\n\nIntroduction\n\n\nThis should provide a (reasonable) introduction to the Erlang bindings for OpenMVG.\nThroughout this tutorial, we should cover:\n1. Creating a C++ \n-\n C API binding\n2. Creating the C API \n-\n Erlang binding", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-the-openmvg-erlang-tutorial", 
            "text": "", 
            "title": "Welcome to the OpenMVG Erlang Tutorial"
        }, 
        {
            "location": "/#introduction", 
            "text": "This should provide a (reasonable) introduction to the Erlang bindings for OpenMVG.\nThroughout this tutorial, we should cover:\n1. Creating a C++  -  C API binding\n2. Creating the C API  -  Erlang binding", 
            "title": "Introduction"
        }, 
        {
            "location": "/tutorial1/", 
            "text": "Creating the C++ \n-\n C header\n\n\nWhen creating the initial Erlang link, we must first create a transparency layer from mangled C++ declarations into unmangled C declarations.\nThis allows the Erlang interpreter to directly address specific natively-implemented functions (NIFs) declared within generated shared objects. When calling NIFs, the Erlang interpreter \nmust\n be able to directly call each NIF by generated function name. If the name happens to be mangled, the burden of addressing each specific function falls onto the end user. To avoid this and ensure maintainability, we force the user to create a C++ \n-\n C binding layer.\n\n\nTo initially create our layer, we create a \ntypedef\n from a \nconst struct*\n type to a custom defined type. This appears as such:\n\n\ntypedef const struct* OpaqueClass OpaquePtr;\n\n\n\n\nCreating a \ntypedef\n statement simply masks our constant structure as a type. This allows one to deal with each type independently of the \nconst struct*\n snippet.\n\n\nNext, we forward-declare which class with which to associate this pointer.\n\n\nnamespace openMVG {\n  namespace foo {\n    class Bar;\n  }\n}\n\n\n\n\nThis enables us to declare--\nwithout\n defining--a specific C++ class and create the necessary association to the opaque C pointer. The reasoning behind this concept is important: from here, we can cast back and forth between C opaque pointers and C++ classes without needing to include all data. Typechecking between C and C++ data structures becomes possible, and casting between both types enables us to transform opaque C data to a declared C++ class. Furthermore, compilation time plummets due to less compilation-intensive header files from being included within the C++ bindings.\n\n\nThe compiler must know which C types to associate to which C++ types. Therefore, a casting system is necessary. To alleviate burden from the end user, one can create a specialized C++ template function that can swizzle types between C and C++. The functions are listed below.\n\n\ntemplate\ntypename APIType\n struct APITypeInfo;\ntemplate\ntypename ImplType\n struct ImplTypeInfo;\n\n#define ADD_API_MAPPING(TheAPIType, TheImplType) \\\ntemplate\n struct APITypeInfo\nTheAPIType\n { typedef TheImplType ImplType; }; \\\ntemplate\n struct ImplTypeInfo\nTheImplType\n { typedef TheAPIType APIType; };\n\ntemplate\ntypename T, typename APIType = typename ImplTypeInfo\nT\n::APIType\n\nauto toAPI(T* t) -\n APIType\n{\n    return reinterpret_cast\nAPIType\n(t);\n}\n\ntemplate\ntypename T, typename ImplType = typename APITypeInfo\nT\n::ImplType\n\nauto toImpl(T t) -\n ImplType*\n{\n    return static_cast\nImplType*\n(static_cast\nvoid*\n(const_cast\ntypename std::remove_const\ntypename std::remove_pointer\nT\n::type\n::type*\n(t)));\n}\n\n\n\n\nLet's break this down.\n\n\ntemplate\ntypename APIType\n struct APITypeInfo;\ntemplate\ntypename ImplType\n struct ImplTypeInfo;\n\n\n\n\nThese two lines define \nAPITypeInfo\n and \nInplTypeInfo\n as specializations of templating functions. When given a specific type, \nAPITypeInfo\n and \nImplTypeInfo\n transform into specific types.\n\n\n#define ADD_API_MAPPING(TheAPIType, TheImplType) \\\ntemplate\n struct APITypeInfo\nTheAPIType\n { typedef TheImplType ImplType; }; \\\ntemplate\n struct ImplTypeInfo\nTheImplType\n { typedef TheAPIType APIType; };\n\n\n\n\nThis defines a macro (\nADD_API_MAPPING\n) that takes two types and creates a specialized template function for each type given. Understanding \ntemplate\n syntax is crucial for understanding how this works: this construct allows for \nonly\n specific types of a C++ templated function to be instantiated. If this templated function is called without a type or with an undefined type, the compiler prohibits compilation.\n\n\ntemplate\ntypename T, typename APIType = typename ImplTypeInfo\nT\n::APIType\n\nauto toAPI(T* t) -\n APIType\n{\n    return reinterpret_cast\nAPIType\n(t);\n}\n\ntemplate\ntypename T, typename ImplType = typename APITypeInfo\nT\n::ImplType\n\nauto toImpl(T t) -\n ImplType*\n{\n    return static_cast\nImplType*\n(static_cast\nvoid*\n(const_cast\ntypename std::remove_const\ntypename std::remove_pointer\nT\n::type\n::type*\n(t)));\n}\n\n\n\n\nFinally, the \ntoAPI\n and \ntoImpl\n functions are declared. These parse given types and their bound compliments, and they cast between C and C++. These lines are where the magic happens: given a specific type, we can pull out the type and reinterpret it to another language's complimentary type.\n\n\nNow that this exists, typecasting between C++ and C becomes simple. We can just declare an association in the header file, as such:\n\n\nADD_API_MAPPING(OpaquePtr, openMVG::foo::Bar)\n\n\n\n\nand automatically generate all bindings necessary to call \ntoAPI\n/\ntoImpl\n on a \nopenMVG::foo::Bar\n/\nOpaquePtr\n object, respectively.\n\n\nThe entire header file is listed here:\n\n\n// shared_api_cast.h\n#pragma once\ntypedef const struct* OpaqueClass OpaquePtr;\n\nnamespace openMVG {\n  namespace foo {\n    class Bar;\n  }\n}\n\ntemplate\ntypename APIType\n struct APITypeInfo;\ntemplate\ntypename ImplType\n struct ImplTypeInfo;\n\n#define ADD_API_MAPPING(TheAPIType, TheImplType) \\\ntemplate\n struct APITypeInfo\nTheAPIType\n { typedef TheImplType ImplType; }; \\\ntemplate\n struct ImplTypeInfo\nTheImplType\n { typedef TheAPIType APIType; };\n\ntemplate\ntypename T, typename APIType = typename ImplTypeInfo\nT\n::APIType\n\nauto toAPI(T* t) -\n APIType\n{\n    return reinterpret_cast\nAPIType\n(t);\n}\n\ntemplate\ntypename T, typename ImplType = typename APITypeInfo\nT\n::ImplType\n\nauto toImpl(T t) -\n ImplType*\n{\n    return static_cast\nImplType*\n(static_cast\nvoid*\n(const_cast\ntypename std::remove_const\ntypename std::remove_pointer\nT\n::type\n::type*\n(t)));\n}\n\n// And here's where you can bind\n\nADD_API_MAPPING(OpaquePtr, openMVG::foo::Bar)\n\n\n\n\nDefining the C header and source file\n\n\nNow that the compiler is informed of all type swapping between opaque pointers and forward-declared classes, it is able to now auto-swizzle types between C and C++. This definition now can be exposed to all C++ and C files that use each opaque pointer and forward-declared class. We must declare methods to interact with our defined opaque pointers.\n\n\nFor this example, assume that the class \nopenMVG::foo::Bar\n has three main methods: a constructor, a destructor, and a method \nint add1(int)\n. So, the class definition would appear as so:\n\n\n// Bar.h\n#pragma once\nnamespace openMVG {\n\nnamespace foo {\n\nclass Bar {\npublic:\n  Bar();\n  int add1(int x) { return x + 1 }\n  ~Bar();\n};\n\n}\n\n}\n\n\n\n\nIf this class were instantiated, each public member could easily be accessed and called by the developer. But because we cannot instantiate this class in pure C, we must rely on the opaque pointer to hold and access each member function. Therefore, we must define methods that prohibit the C++ compiler from mangling C headers containing the opaque pointer, while allowing the functions inside the declaration to be mangled.\n\n\nFirst, we must define a C++ header in which we express the interaction with our base opaque pointers. A sample C++ header is defined as such:\n\n\n// Bar_API.h\n#pragma once\n\n#include \nshared_api_cast.h\n\n\n#ifdef __cplusplus\nextern \nC\n {\n#endif\n\nOpaquePtr barPtrCreate();\n\nint barPtrAdd1(OpaquePtr, int);\nvoid barPtrDelete(OpaquePtr);\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\nAs observed, the primary C interaction will entail instantiating and manipulating an \nOpaquePtr\n pointing to our C++ class. We need the \nextern C\n blocks: we must disable the C++ compiler from mangling these function headers, which the \nextern C\n blocks perform. From here, we can ensure the Erlang interpreter will be able to find these specific functions while loading the native library.\n\n\nFrom here, we must define the C functions. This looks as follows:\n\n\n// Bar_API.cpp\n#include \nBar_API.h\n\n#include \nBar.h\n\n\nOpaquePtr barPtrCreate() {\n  openMVG::foo::Bar* barCpp = new openMVG::foo::Bar();\n  return toAPI(barCpp);\n}\n\nint barPtrAdd1(OpaquePtr ptr, int x) {\n  openMVG::foo::Bar* barCpp = toImpl(ptr);\n  return barCpp-\nadd1(x);\n}\n\nvoid barPtrDelete(OpaquePtr ptr) {\n  openMVG::foo::Bar* barCpp = toImpl(ptr);\n  delete barCpp;\n}\n\n\n\n\nAs observed, each C function is defined with C++ code being called inside. The ability to call C++ from C lies in the C++ compiler's internal mapping mechanism. The C functions remain unmangled at the definition, but inside the C++ compiler can mangle and link any valid C++ code. This part is \ncrucial\n to understanding the methods through which one can link C to C++. Because this code is compiled by a C++ compiler, the C++ compiler can compile C++ code inside of a C-facing function. This allows for the instantiation of C++ objects to C opaque pointers, thereby allowing access to all of C++ from C (especially the \ntoAPI\n and \ntoImpl\n functions).\n\n\nFor simplicity's sake, each interaction above first starts with a sole line for a C++ class pointer for specifically reinterpreting the C opaque pointer. A more compact form is presented as such:\n\n\n// Bar_API.cpp\n#include \nBar_API.h\n\n#include \nBar.h\n\n\nOpaquePtr barPtrCreate() {\n  return toAPI(new openMVG::foo::Bar());\n}\n\nint barPtrAdd1(OpaquePtr ptr, int x) {\n  return toImpl(ptr)-\nadd1(x);\n}\n\nvoid barPtrDelete(OpaquePtr ptr) {\n  delete toImpl(barCpp);\n}\n\n\n\n\nAs seen above, the \ntoImpl\n and \ntoAPI\n functions can contain valid calls to C++ not only within their function call, but also appended to their call. For example, the arrow sign appended to the end of a \ntoImpl\n call is completely valid: the type at the time is C++.\n\n\nIn the next section, we shall explore how to export these C functions to Erlang.", 
            "title": "1: C++ <-> C"
        }, 
        {
            "location": "/tutorial1/#creating-the-c-c-header", 
            "text": "When creating the initial Erlang link, we must first create a transparency layer from mangled C++ declarations into unmangled C declarations.\nThis allows the Erlang interpreter to directly address specific natively-implemented functions (NIFs) declared within generated shared objects. When calling NIFs, the Erlang interpreter  must  be able to directly call each NIF by generated function name. If the name happens to be mangled, the burden of addressing each specific function falls onto the end user. To avoid this and ensure maintainability, we force the user to create a C++  -  C binding layer.  To initially create our layer, we create a  typedef  from a  const struct*  type to a custom defined type. This appears as such:  typedef const struct* OpaqueClass OpaquePtr;  Creating a  typedef  statement simply masks our constant structure as a type. This allows one to deal with each type independently of the  const struct*  snippet.  Next, we forward-declare which class with which to associate this pointer.  namespace openMVG {\n  namespace foo {\n    class Bar;\n  }\n}  This enables us to declare-- without  defining--a specific C++ class and create the necessary association to the opaque C pointer. The reasoning behind this concept is important: from here, we can cast back and forth between C opaque pointers and C++ classes without needing to include all data. Typechecking between C and C++ data structures becomes possible, and casting between both types enables us to transform opaque C data to a declared C++ class. Furthermore, compilation time plummets due to less compilation-intensive header files from being included within the C++ bindings.  The compiler must know which C types to associate to which C++ types. Therefore, a casting system is necessary. To alleviate burden from the end user, one can create a specialized C++ template function that can swizzle types between C and C++. The functions are listed below.  template typename APIType  struct APITypeInfo;\ntemplate typename ImplType  struct ImplTypeInfo;\n\n#define ADD_API_MAPPING(TheAPIType, TheImplType) \\\ntemplate  struct APITypeInfo TheAPIType  { typedef TheImplType ImplType; }; \\\ntemplate  struct ImplTypeInfo TheImplType  { typedef TheAPIType APIType; };\n\ntemplate typename T, typename APIType = typename ImplTypeInfo T ::APIType \nauto toAPI(T* t) -  APIType\n{\n    return reinterpret_cast APIType (t);\n}\n\ntemplate typename T, typename ImplType = typename APITypeInfo T ::ImplType \nauto toImpl(T t) -  ImplType*\n{\n    return static_cast ImplType* (static_cast void* (const_cast typename std::remove_const typename std::remove_pointer T ::type ::type* (t)));\n}  Let's break this down.  template typename APIType  struct APITypeInfo;\ntemplate typename ImplType  struct ImplTypeInfo;  These two lines define  APITypeInfo  and  InplTypeInfo  as specializations of templating functions. When given a specific type,  APITypeInfo  and  ImplTypeInfo  transform into specific types.  #define ADD_API_MAPPING(TheAPIType, TheImplType) \\\ntemplate  struct APITypeInfo TheAPIType  { typedef TheImplType ImplType; }; \\\ntemplate  struct ImplTypeInfo TheImplType  { typedef TheAPIType APIType; };  This defines a macro ( ADD_API_MAPPING ) that takes two types and creates a specialized template function for each type given. Understanding  template  syntax is crucial for understanding how this works: this construct allows for  only  specific types of a C++ templated function to be instantiated. If this templated function is called without a type or with an undefined type, the compiler prohibits compilation.  template typename T, typename APIType = typename ImplTypeInfo T ::APIType \nauto toAPI(T* t) -  APIType\n{\n    return reinterpret_cast APIType (t);\n}\n\ntemplate typename T, typename ImplType = typename APITypeInfo T ::ImplType \nauto toImpl(T t) -  ImplType*\n{\n    return static_cast ImplType* (static_cast void* (const_cast typename std::remove_const typename std::remove_pointer T ::type ::type* (t)));\n}  Finally, the  toAPI  and  toImpl  functions are declared. These parse given types and their bound compliments, and they cast between C and C++. These lines are where the magic happens: given a specific type, we can pull out the type and reinterpret it to another language's complimentary type.  Now that this exists, typecasting between C++ and C becomes simple. We can just declare an association in the header file, as such:  ADD_API_MAPPING(OpaquePtr, openMVG::foo::Bar)  and automatically generate all bindings necessary to call  toAPI / toImpl  on a  openMVG::foo::Bar / OpaquePtr  object, respectively.  The entire header file is listed here:  // shared_api_cast.h\n#pragma once\ntypedef const struct* OpaqueClass OpaquePtr;\n\nnamespace openMVG {\n  namespace foo {\n    class Bar;\n  }\n}\n\ntemplate typename APIType  struct APITypeInfo;\ntemplate typename ImplType  struct ImplTypeInfo;\n\n#define ADD_API_MAPPING(TheAPIType, TheImplType) \\\ntemplate  struct APITypeInfo TheAPIType  { typedef TheImplType ImplType; }; \\\ntemplate  struct ImplTypeInfo TheImplType  { typedef TheAPIType APIType; };\n\ntemplate typename T, typename APIType = typename ImplTypeInfo T ::APIType \nauto toAPI(T* t) -  APIType\n{\n    return reinterpret_cast APIType (t);\n}\n\ntemplate typename T, typename ImplType = typename APITypeInfo T ::ImplType \nauto toImpl(T t) -  ImplType*\n{\n    return static_cast ImplType* (static_cast void* (const_cast typename std::remove_const typename std::remove_pointer T ::type ::type* (t)));\n}\n\n// And here's where you can bind\n\nADD_API_MAPPING(OpaquePtr, openMVG::foo::Bar)", 
            "title": "Creating the C++ &lt;-&gt; C header"
        }, 
        {
            "location": "/tutorial1/#defining-the-c-header-and-source-file", 
            "text": "Now that the compiler is informed of all type swapping between opaque pointers and forward-declared classes, it is able to now auto-swizzle types between C and C++. This definition now can be exposed to all C++ and C files that use each opaque pointer and forward-declared class. We must declare methods to interact with our defined opaque pointers.  For this example, assume that the class  openMVG::foo::Bar  has three main methods: a constructor, a destructor, and a method  int add1(int) . So, the class definition would appear as so:  // Bar.h\n#pragma once\nnamespace openMVG {\n\nnamespace foo {\n\nclass Bar {\npublic:\n  Bar();\n  int add1(int x) { return x + 1 }\n  ~Bar();\n};\n\n}\n\n}  If this class were instantiated, each public member could easily be accessed and called by the developer. But because we cannot instantiate this class in pure C, we must rely on the opaque pointer to hold and access each member function. Therefore, we must define methods that prohibit the C++ compiler from mangling C headers containing the opaque pointer, while allowing the functions inside the declaration to be mangled.  First, we must define a C++ header in which we express the interaction with our base opaque pointers. A sample C++ header is defined as such:  // Bar_API.h\n#pragma once\n\n#include  shared_api_cast.h \n\n#ifdef __cplusplus\nextern  C  {\n#endif\n\nOpaquePtr barPtrCreate();\n\nint barPtrAdd1(OpaquePtr, int);\nvoid barPtrDelete(OpaquePtr);\n\n#ifdef __cplusplus\n}\n#endif  As observed, the primary C interaction will entail instantiating and manipulating an  OpaquePtr  pointing to our C++ class. We need the  extern C  blocks: we must disable the C++ compiler from mangling these function headers, which the  extern C  blocks perform. From here, we can ensure the Erlang interpreter will be able to find these specific functions while loading the native library.  From here, we must define the C functions. This looks as follows:  // Bar_API.cpp\n#include  Bar_API.h \n#include  Bar.h \n\nOpaquePtr barPtrCreate() {\n  openMVG::foo::Bar* barCpp = new openMVG::foo::Bar();\n  return toAPI(barCpp);\n}\n\nint barPtrAdd1(OpaquePtr ptr, int x) {\n  openMVG::foo::Bar* barCpp = toImpl(ptr);\n  return barCpp- add1(x);\n}\n\nvoid barPtrDelete(OpaquePtr ptr) {\n  openMVG::foo::Bar* barCpp = toImpl(ptr);\n  delete barCpp;\n}  As observed, each C function is defined with C++ code being called inside. The ability to call C++ from C lies in the C++ compiler's internal mapping mechanism. The C functions remain unmangled at the definition, but inside the C++ compiler can mangle and link any valid C++ code. This part is  crucial  to understanding the methods through which one can link C to C++. Because this code is compiled by a C++ compiler, the C++ compiler can compile C++ code inside of a C-facing function. This allows for the instantiation of C++ objects to C opaque pointers, thereby allowing access to all of C++ from C (especially the  toAPI  and  toImpl  functions).  For simplicity's sake, each interaction above first starts with a sole line for a C++ class pointer for specifically reinterpreting the C opaque pointer. A more compact form is presented as such:  // Bar_API.cpp\n#include  Bar_API.h \n#include  Bar.h \n\nOpaquePtr barPtrCreate() {\n  return toAPI(new openMVG::foo::Bar());\n}\n\nint barPtrAdd1(OpaquePtr ptr, int x) {\n  return toImpl(ptr)- add1(x);\n}\n\nvoid barPtrDelete(OpaquePtr ptr) {\n  delete toImpl(barCpp);\n}  As seen above, the  toImpl  and  toAPI  functions can contain valid calls to C++ not only within their function call, but also appended to their call. For example, the arrow sign appended to the end of a  toImpl  call is completely valid: the type at the time is C++.  In the next section, we shall explore how to export these C functions to Erlang.", 
            "title": "Defining the C header and source file"
        }, 
        {
            "location": "/tutorial2/", 
            "text": "Exporting the C to Erlang layer\n\n\nPrerequisites\n\n\nEach prerequisite for this section is listed below:\n\n\n\n\nClang\n\n\nNifty\n\n\nErlang interpreter \n= R17\n\n\n\n\nOn a Nix system, these should already be pulled in from the \ndefault.nix\n file locaed in the nifty folder. To globally add the \nclang\n and \nerlang\n packages, the commands would look like such:\n\n\n# Imperative\nnix-env -i clang erlang\n\n#Declarative\npkgs = [\n  clang\n  erlang\n];\n\n\n\n\nOn Ubuntu, the command would look as such:\n\n\nsudo apt-get install clang erlang\ngit clone https://github.com/parapluu/nifty\ncd nifty ; make\n\n\n\n\nIMPORTANT\n: your Erlang interpreter \nMUST\n include support for dirty scheduling. Without this, native calls block all schedulers within the Erlang ecosystem and choke other processes from completion. On a Nix system, the configuration for enabling dirty scheduling would appear as so:\n\n\nnixpkgs.config = {\n  packageOverrides = super: let self = super.pkgs; in {\n    erlang = super.erlang.override { enableDirtySchedulers = true; };\n  };\n};\n\n\n\n\nOn Ubuntu, a manual configuration and compilation of the Erlang package must be used. First, download the OTP from the \nErlang Website\n. Then, enter the directory and run the following commands:\n\n\n./configure --enable-dirty-schedulers\nmake\n\n\n\n\nThis allows your Erlang distribution to compile with dirty scheduling enabled. Extra prerequisites are necessary to compile Erlang from source; for more information, visit the \ninstall page\n.\n\n\nCreating each C to Erlang binding\n\n\nSo far, you have a header and source file that you have compiled into a shared object. Your Erlang code must be able to load and call each function. Normally, this would require creating specific Erlang bindings manually in C; however, Nifty alleviates this problem through the Clang parsing mechanism. In order to use Nifty globally from the Erlang interpreter, it must first be added to the \nERL_LIBS\n environmental variable within your shell.\n\n\nexport ERL_LIBS=$ERL_LIBS:\npath_to_nifty_install\n\n\n\n\n\nThis enables the Erlang interpreter to find the Nifty installation. From here, one can load and attempt to use Nifty from the Erlang interpeter to ensure its global functionality within your C source directory:\n\n\n1\n nifty:compile(\nBar_API.h\n, bar_api, []).\n\n\n\n\nHopefully, this should return an \nok\n from the Erlang shell. If nifty can't be found, it hasn't yet been included in your \nERL_LIBS\n.\n\n\nThree primary parameters are passed into this function: a header file, an atom of the name you would like to assign to your library, and a list of options. When attempting to load this library from the first time from the Erlang REPL using the command \nl(bar_api)\n, you may see a \"Failed to load NIF error\". This is natural: we haven't appropriately linked against our shared object library. We must specify this in the command. The full command for exporting our header functions while linking against our shared object library is stated as such:\n\n\nnifty:compile(\nBar_API.h\n, bar_api, [\n                                      {port_specs, \n                                        [\n                                          {\n                                            \n.*\n, \n                                            \n$NIF\n, \n                                            [],\n                                            [\n                                              {env, [\n                                                     {\nCFLAGS\n, \n$CFLAGS -I\n ++ \n(PATH_TO_HEADER_DIRECTORY)\n},\n                                                     {\nLDFLAGS\n, \n$LDFLAGS\n ++ \n(PATH_TO_SHARED_OBJECT)\n}\n                                                    ]}\n                                            ]\n                                          }\n                                        ]},\n                                        {nifty, [schedule_dirty]}\n                                    ]).\n\n\n\n\nThe important two variables to observe here are the \nPATH_TO_HEADER_DIRECTORY\n and the \nPATH_TO_SHARED_OBJECT\n. These variables must be specified in order for the compiler to compile and appropriately link your code. Multiple shared linker objects can be specified; in fact, these variables correlate directly with the CFLAGS and LDFLAGS variables found within a standard C compilation system. Inside of the \nenv\n variable, you may list each environment variable that you would like to specify.\n\n\nUsing your object from Erlang\n\n\nNow that the Erlang library bindings have been generated, it's time to test their functionality. Attempt to run the following:\n\n\n1\n bar_api:barPtrCreate().\n\n\n\n\nThis function should return a two-tuple containing a number and a string describing the type. This is completely normal: nifty uses this to describe the postiion and type of the pointer it hands back to you. From this, you can call functions on this object. For example, let's look at calling \nadd1()\n from Erlang.\n\n\n1\n BarObj1 = bar_api:barPtrCreate().\n2\n bar_api:barPtrAdd1(BarObj1, 2).\n\n\n\n\nThis enables us to pass and control C++ objects from Erlang. A lot happens under the hood here, so let's break this down. First, we call an Erlang function \nbar_api:barPtrCreate()\n. If the \nbar_api\n library has not loaded the shared object file into memory, it shall attempt to load the shared object file. Assuming this completes successfully, Erlang will call the C-facing unmangled function listed in the shared object file. This unmangled function will call mangled functions from within the declaration. These functions then complete, returning a C-facing variable which can then be returned to the Erlang interpreter. The Erlang interpreter can then interpret what it receives.\n\n\nThe second portion allows us to pass local memory and Erlang terms to the NIF. If the Erlang term is natively compatible with a C type, nifty will automatically convert the type to a C type. From here, a call is made to the shared object library with the locally instantiated pointer and variable. This action is completed, and a variable is returned to us.\n\n\nFrom here, we can successfully interface with our C/C++ NIF library.", 
            "title": "2: C <-> Erlang"
        }, 
        {
            "location": "/tutorial2/#exporting-the-c-to-erlang-layer", 
            "text": "", 
            "title": "Exporting the C to Erlang layer"
        }, 
        {
            "location": "/tutorial2/#prerequisites", 
            "text": "Each prerequisite for this section is listed below:   Clang  Nifty  Erlang interpreter  = R17   On a Nix system, these should already be pulled in from the  default.nix  file locaed in the nifty folder. To globally add the  clang  and  erlang  packages, the commands would look like such:  # Imperative\nnix-env -i clang erlang\n\n#Declarative\npkgs = [\n  clang\n  erlang\n];  On Ubuntu, the command would look as such:  sudo apt-get install clang erlang\ngit clone https://github.com/parapluu/nifty\ncd nifty ; make  IMPORTANT : your Erlang interpreter  MUST  include support for dirty scheduling. Without this, native calls block all schedulers within the Erlang ecosystem and choke other processes from completion. On a Nix system, the configuration for enabling dirty scheduling would appear as so:  nixpkgs.config = {\n  packageOverrides = super: let self = super.pkgs; in {\n    erlang = super.erlang.override { enableDirtySchedulers = true; };\n  };\n};  On Ubuntu, a manual configuration and compilation of the Erlang package must be used. First, download the OTP from the  Erlang Website . Then, enter the directory and run the following commands:  ./configure --enable-dirty-schedulers\nmake  This allows your Erlang distribution to compile with dirty scheduling enabled. Extra prerequisites are necessary to compile Erlang from source; for more information, visit the  install page .", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/tutorial2/#creating-each-c-to-erlang-binding", 
            "text": "So far, you have a header and source file that you have compiled into a shared object. Your Erlang code must be able to load and call each function. Normally, this would require creating specific Erlang bindings manually in C; however, Nifty alleviates this problem through the Clang parsing mechanism. In order to use Nifty globally from the Erlang interpreter, it must first be added to the  ERL_LIBS  environmental variable within your shell.  export ERL_LIBS=$ERL_LIBS: path_to_nifty_install   This enables the Erlang interpreter to find the Nifty installation. From here, one can load and attempt to use Nifty from the Erlang interpeter to ensure its global functionality within your C source directory:  1  nifty:compile( Bar_API.h , bar_api, []).  Hopefully, this should return an  ok  from the Erlang shell. If nifty can't be found, it hasn't yet been included in your  ERL_LIBS .  Three primary parameters are passed into this function: a header file, an atom of the name you would like to assign to your library, and a list of options. When attempting to load this library from the first time from the Erlang REPL using the command  l(bar_api) , you may see a \"Failed to load NIF error\". This is natural: we haven't appropriately linked against our shared object library. We must specify this in the command. The full command for exporting our header functions while linking against our shared object library is stated as such:  nifty:compile( Bar_API.h , bar_api, [\n                                      {port_specs, \n                                        [\n                                          {\n                                             .* , \n                                             $NIF , \n                                            [],\n                                            [\n                                              {env, [\n                                                     { CFLAGS ,  $CFLAGS -I  ++  (PATH_TO_HEADER_DIRECTORY) },\n                                                     { LDFLAGS ,  $LDFLAGS  ++  (PATH_TO_SHARED_OBJECT) }\n                                                    ]}\n                                            ]\n                                          }\n                                        ]},\n                                        {nifty, [schedule_dirty]}\n                                    ]).  The important two variables to observe here are the  PATH_TO_HEADER_DIRECTORY  and the  PATH_TO_SHARED_OBJECT . These variables must be specified in order for the compiler to compile and appropriately link your code. Multiple shared linker objects can be specified; in fact, these variables correlate directly with the CFLAGS and LDFLAGS variables found within a standard C compilation system. Inside of the  env  variable, you may list each environment variable that you would like to specify.", 
            "title": "Creating each C to Erlang binding"
        }, 
        {
            "location": "/tutorial2/#using-your-object-from-erlang", 
            "text": "Now that the Erlang library bindings have been generated, it's time to test their functionality. Attempt to run the following:  1  bar_api:barPtrCreate().  This function should return a two-tuple containing a number and a string describing the type. This is completely normal: nifty uses this to describe the postiion and type of the pointer it hands back to you. From this, you can call functions on this object. For example, let's look at calling  add1()  from Erlang.  1  BarObj1 = bar_api:barPtrCreate().\n2  bar_api:barPtrAdd1(BarObj1, 2).  This enables us to pass and control C++ objects from Erlang. A lot happens under the hood here, so let's break this down. First, we call an Erlang function  bar_api:barPtrCreate() . If the  bar_api  library has not loaded the shared object file into memory, it shall attempt to load the shared object file. Assuming this completes successfully, Erlang will call the C-facing unmangled function listed in the shared object file. This unmangled function will call mangled functions from within the declaration. These functions then complete, returning a C-facing variable which can then be returned to the Erlang interpreter. The Erlang interpreter can then interpret what it receives.  The second portion allows us to pass local memory and Erlang terms to the NIF. If the Erlang term is natively compatible with a C type, nifty will automatically convert the type to a C type. From here, a call is made to the shared object library with the locally instantiated pointer and variable. This action is completed, and a variable is returned to us.  From here, we can successfully interface with our C/C++ NIF library.", 
            "title": "Using your object from Erlang"
        }
    ]
}